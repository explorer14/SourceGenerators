using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Collections.Immutable;
using System.Linq;
using System.Text;

namespace DtoGenerators
{
    [Generator]
    public class MappedDtoGenerator : ISourceGenerator
    {
        public void Execute(GeneratorExecutionContext context)
        {
            var targetTypeTracker = context.SyntaxContextReceiver as TargetTypeTracker;
            ReportWarningIfReceiverNotFound(context, targetTypeTracker);
            var codeBuilder = new StringBuilder();

            foreach (var typeNode in targetTypeTracker.TypesNeedingDtoGening)
            {
                var entityClassNamespace = typeNode.ContainingNamespace();
                var generatedDtoClassName = $"{typeNode.Identifier.ValueText}Dto";

                AddUsings(codeBuilder, entityClassNamespace);
                AddAutoGenComment(codeBuilder);
                AddStartNamespace(codeBuilder, entityClassNamespace);
                AddStartContainerType(codeBuilder, generatedDtoClassName);
                // TODO: add members and mapping code
                AddEndContainerType(codeBuilder);
                AddEndNamespace(codeBuilder);

                context.AddSource(generatedDtoClassName,
                    SourceText.From(codeBuilder.ToString(), Encoding.UTF8));
                codeBuilder.Clear();
            }
        }

        private static void ReportWarningIfReceiverNotFound(
            GeneratorExecutionContext context,
            TargetTypeTracker targetTypeTracker)
        {
            if (targetTypeTracker == null)
                context.ReportDiagnostic(
                    Diagnostic.Create(
                        new DiagnosticDescriptor(
                            "DTOGEN",
                            "DtoGenerator",
                            "No ISyntaxContextReciever implementation found!",
                            "DTO Gen",
                            DiagnosticSeverity.Warning, true),
                        Location.None));
        }

        private void AddAutoGenComment(StringBuilder codeBuilder) =>
            codeBuilder.AppendLine("// Generated by DtoGenerator © Aman Agrawal");

        private static void AddEndNamespace(StringBuilder codeBuilder)
        {
            codeBuilder.AppendLine("}");
        }

        private static void AddEndContainerType(StringBuilder codeBuilder)
        {
            codeBuilder.AppendLine("\t}");
        }

        private static void AddStartContainerType(StringBuilder codeBuilder, string generatedDtoName)
        {
            codeBuilder.AppendLine($"\tpublic class {generatedDtoName}");
            codeBuilder.AppendLine("\t{");
        }

        private static void AddStartNamespace(StringBuilder codeBuilder, string entityNamespace)
        {
            codeBuilder.AppendLine($"namespace {entityNamespace}.Dtos");
            codeBuilder.AppendLine("{");
        }

        private static void AddUsings(StringBuilder codeBuilder, string entityNamespace)
        {
            codeBuilder.AppendLine("using System;");
            codeBuilder.AppendLine("using System.Collections.Generic;");
            codeBuilder.AppendLine("using System.Linq;");

            codeBuilder.AppendLine($"using {entityNamespace};");
        }

        public void Initialize(GeneratorInitializationContext context) =>
            context.RegisterForSyntaxNotifications(() => new TargetTypeTracker());
    }

    public class TargetTypeTracker : ISyntaxContextReceiver
    {
        public IImmutableList<TypeDeclarationSyntax> TypesNeedingDtoGening =
            ImmutableList.Create<TypeDeclarationSyntax>();

        public void OnVisitSyntaxNode(GeneratorSyntaxContext context)
        {
            if (context.Node is TypeDeclarationSyntax cdecl)
                if (cdecl.IsDecoratedWithAttribute("generatemappeddto"))
                    TypesNeedingDtoGening = TypesNeedingDtoGening.Add(
                        context.Node as TypeDeclarationSyntax);
        }
    }

    internal static class SourceGenExtns
    {
        internal static bool IsDecoratedWithAttribute(
            this TypeDeclarationSyntax cdecl, string attributeName) =>
            cdecl.AttributeLists
                .SelectMany(x => x.Attributes)
                .Any(x => x.Name.ToString().ToLower() == attributeName);

        internal static string ContainingNamespace(this TypeDeclarationSyntax cdecl) =>
            (cdecl.Parent as NamespaceDeclarationSyntax)?.Name.ToString() ?? "NoNamespace";
    }
}