using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;

namespace DtoGenerators
{
    [Generator]
    public class MappedDtoGenerator : ISourceGenerator
    {
        public void Execute(GeneratorExecutionContext context)
        {
            var targetTypeTracker = context.SyntaxContextReceiver as TargetTypeTracker;
            ReportWarningIfReceiverNotFound(context, targetTypeTracker);
            var codeBuilder = new StringBuilder();

            foreach (var typeNode in targetTypeTracker.TypesNeedingDtoGening)
            {
                var entityClassNamespace = typeNode.ContainingNamespace();
                var generatedDtoClassName = $"{typeNode.Identifier.ValueText}Dto";

                AddUsings(codeBuilder, entityClassNamespace);
                AddAutoGenComment(codeBuilder);
                AddStartNamespace(codeBuilder, entityClassNamespace);
                AddStartContainerType(codeBuilder, generatedDtoClassName);
                AddContainerTypeMembers(codeBuilder, typeNode, context.Compilation);
                AddEndContainerType(codeBuilder);
                AddEntityToDtoConversionExtensionMethods(
                    codeBuilder, typeNode, 
                    generatedDtoClassName, context.Compilation);
                AddEndNamespace(codeBuilder);

                context.AddSource(generatedDtoClassName,
                    SourceText.From(codeBuilder.ToString(), Encoding.UTF8));
                codeBuilder.Clear();
            }
        }

        private static void ReportWarningIfReceiverNotFound(
            GeneratorExecutionContext context,
            TargetTypeTracker targetTypeTracker)
        {
            if (targetTypeTracker == null)
                context.ReportDiagnostic(
                    Diagnostic.Create(
                        new DiagnosticDescriptor(
                            "DTOGEN",
                            "DtoGenerator",
                            "No ISyntaxContextReciever implementation found!",
                            "DTO Gen",
                            DiagnosticSeverity.Warning, true),
                        Location.None));
        }

        private void AddAutoGenComment(StringBuilder codeBuilder) =>
            codeBuilder.AppendLine("// Generated by DtoGenerators © Aman Agrawal");

        private static void AddEndNamespace(StringBuilder codeBuilder) => 
            codeBuilder.AppendLine("}");

        private static void AddEndContainerType(StringBuilder codeBuilder) => 
            codeBuilder.AppendLine("\t}");

        private static void AddStartContainerType(StringBuilder codeBuilder, string generatedDtoName)
        {
            codeBuilder.AppendLine($"\tpublic class {generatedDtoName}");
            codeBuilder.AppendLine("\t{");
        }

        private static void AddStartNamespace(StringBuilder codeBuilder, string entityNamespace)
        {
            codeBuilder.AppendLine($"namespace {entityNamespace}.Dtos");
            codeBuilder.AppendLine("{");
        }

        private static void AddUsings(StringBuilder codeBuilder, string entityNamespace)
        {
            codeBuilder.AppendLine("using System;");
            codeBuilder.AppendLine("using System.Collections.Generic;");
            codeBuilder.AppendLine("using System.Linq;");

            codeBuilder.AppendLine($"using {entityNamespace};");
        }

        private static void AddContainerTypeMembers(
            StringBuilder codeBuilder, 
            TypeDeclarationSyntax cls, 
            Compilation compilation)
        {
            foreach (var item in cls.Members)
                if (item is PropertyDeclarationSyntax pds)
                    codeBuilder.AppendLine($"\t\t{pds.BuildDtoProperty(compilation)}");
        }

        private static void AddEntityToDtoConversionExtensionMethods(
            StringBuilder codeBuilder,
            TypeDeclarationSyntax cls,
            string generatedDtoName,
            Compilation compilation)
        {
            codeBuilder.AppendLine($"\tpublic static class EntityExtensions{Guid.NewGuid().ToString().Replace("-", string.Empty)}");
            codeBuilder.AppendLine("\t{");
            codeBuilder.AppendLine($"\t\tpublic static {generatedDtoName} ToDto(this {cls.Identifier.ValueText} entity)");
            codeBuilder.AppendLine("\t\t{");
            codeBuilder.AppendLine($"\t\t\t\treturn new {generatedDtoName}");
            codeBuilder.AppendLine($"\t\t\t\t{{");

            var propertiesWithGenericTypeArguments = new List<PropertyDeclarationSyntax>();

            foreach (var item in cls.Members)
            {
                if (item is PropertyDeclarationSyntax pds)
                {
                    if (pds.ChildNodes().Count(x => x is GenericNameSyntax) > 0)
                    {
                        var gns = (pds.ChildNodes().Where(x => x is GenericNameSyntax).FirstOrDefault()) as GenericNameSyntax;

                        if (gns.TypeArgumentList.Arguments.All(x => x is PredefinedTypeSyntax))
                            codeBuilder.AppendLine($"\t\t\t\t\t{pds.Identifier.ValueText} = entity.{ pds.Identifier.ValueText},");
                        else
                        {
                            codeBuilder.AppendLine($"\t\t\t\t\t{pds.Identifier.ValueText} = entity.{ pds.Identifier.ValueText}.ToDto(),");
                            propertiesWithGenericTypeArguments.Add(pds);
                        }
                    }
                    else
                    {
                        var blah = compilation.GetSemanticModel(pds.SyntaxTree).GetDeclaredSymbol(pds);
                        var propSym = (blah as IPropertySymbol);
                        if (propSym.IsOfTypeClass() || propSym.IsOfTypeStruct())
                            codeBuilder.AppendLine($"\t\t\t\t\t{pds.Identifier.ValueText} = entity.{ pds.Identifier.ValueText}.ToDto(),");
                        else
                            codeBuilder.AppendLine($"\t\t\t\t\t{pds.Identifier.ValueText} = entity.{ pds.Identifier.ValueText},");
                    }
                }
            }

            codeBuilder.AppendLine($"\t\t\t\t}};");
            codeBuilder.AppendLine("\t\t}");
            codeBuilder.AppendLine("\t}");

            // add conversion extensions for generic type properties
            // this assumes collection type properties. What about scalar properties of complex types?
            foreach (var property in propertiesWithGenericTypeArguments)
            {
                var gns = (property.ChildNodes().Where(x => x is GenericNameSyntax).FirstOrDefault()) as GenericNameSyntax;

                if (gns.TypeArgumentList.Arguments.Any(x => x is not PredefinedTypeSyntax))
                {
                    codeBuilder.AppendLine($"\tpublic static class EntityExtensions{Guid.NewGuid().ToString().Replace("-", string.Empty)}");
                    codeBuilder.AppendLine("\t{");
                    codeBuilder.AppendLine($"\t\tpublic static {property.GetGenericTypeForDto()} ToDto(this {property.GetGenericTypeForEntity()} entities)");
                    codeBuilder.AppendLine("\t\t\t=> entities.Select(x=>x.ToDto()).ToList();");
                    codeBuilder.AppendLine("\t}");
                }
            }
        }

        public void Initialize(GeneratorInitializationContext context) =>
            context.RegisterForSyntaxNotifications(() => new TargetTypeTracker());
    }

    public class TargetTypeTracker : ISyntaxContextReceiver
    {
        public IImmutableList<TypeDeclarationSyntax> TypesNeedingDtoGening =
            ImmutableList.Create<TypeDeclarationSyntax>();

        public void OnVisitSyntaxNode(GeneratorSyntaxContext context)
        {
            if (context.Node is TypeDeclarationSyntax cdecl)
                if (cdecl.IsDecoratedWithAttribute("generatemappeddto"))
                    TypesNeedingDtoGening = TypesNeedingDtoGening.Add(
                        context.Node as TypeDeclarationSyntax);
        }
    }

    internal static class SourceGenExtns
    {
        internal static bool IsDecoratedWithAttribute(
            this TypeDeclarationSyntax cdecl, string attributeName) =>
            cdecl.AttributeLists
                .SelectMany(x => x.Attributes)
                .Any(x => x.Name.ToString().ToLower() == attributeName);

        internal static string ContainingNamespace(this TypeDeclarationSyntax cdecl) =>
            (cdecl.Parent as NamespaceDeclarationSyntax)?.Name.ToString() ?? "NoNamespace";

        internal static string BuildDtoProperty(this PropertyDeclarationSyntax pds, Compilation compilation)
        {
            if (pds.ChildNodes().Count(x => x is GenericNameSyntax) > 0)
            {
                var gns = (pds.ChildNodes().Where(x => x is GenericNameSyntax).FirstOrDefault()) as GenericNameSyntax;
                return $"public {pds.GetGenericTypeForDto()} {pds.Identifier.ValueText} {{get; set;}}";
            }
            else
            {
                var blah = compilation.GetSemanticModel(pds.SyntaxTree).GetDeclaredSymbol(pds);
                var propSym = (blah as IPropertySymbol);

                if (propSym.IsOfTypeClass() || propSym.IsOfTypeStruct())
                {
                    return $"public {pds.Type}Dto {pds.Identifier.ValueText} {{get; set;}}";
                }
                else
                {
                    return $"public {pds.Type} {pds.Identifier.ValueText} {{get; set;}}";
                }
            }
        }

        internal static string GetGenericTypeForDto(this PropertyDeclarationSyntax pds)
        {
            var gns = (pds.ChildNodes().Where(x => x is GenericNameSyntax).FirstOrDefault()) as GenericNameSyntax;

            var argumentListCsv = string.Empty;

            foreach (var arg in gns.TypeArgumentList.Arguments)
            {
                if (arg is PredefinedTypeSyntax pts)
                    argumentListCsv = string.Join(",", argumentListCsv, pts.ToString());
                else
                    argumentListCsv = string.Join(",", argumentListCsv, $"{arg}Dto");
            }

            return $"{gns.Identifier.ValueText}<{argumentListCsv.TrimStart(',')}>";
        }

        internal static string GetGenericTypeForEntity(this PropertyDeclarationSyntax pds)
        {
            var gns = (pds.ChildNodes().Where(x => x is GenericNameSyntax).FirstOrDefault()) as GenericNameSyntax;

            return $"{gns.Identifier.ValueText}<{string.Join(",", gns.TypeArgumentList.Arguments.Select(x => $"{x}"))}>";
        }

        internal static bool IsOfTypeClass(this IPropertySymbol propSym) =>
            propSym.Type.BaseType.ToDisplayString() == "object" &&
            propSym.Type.IsReferenceType &&
            propSym.Type.TypeKind == TypeKind.Class &&
            propSym.Type.ToDisplayString() != "string" &&
            propSym.Type.ToDisplayString().StartsWith(propSym.ContainingNamespace.ToDisplayString());

        internal static bool IsOfTypeStruct(this IPropertySymbol propSym) =>
            propSym.Type.IsValueType &&
            propSym.Type.TypeKind == TypeKind.Struct &&
            propSym.Type.ToDisplayString().StartsWith(propSym.ContainingNamespace.ToDisplayString());
    }
}